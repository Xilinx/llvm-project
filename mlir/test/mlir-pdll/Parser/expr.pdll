// RUN: mlir-pdll %s -I %S -I %S/../../../include -split-input-file | FileCheck %s

//===----------------------------------------------------------------------===//
// AttrExpr
//===----------------------------------------------------------------------===//

// CHECK: Module
// CHECK: `-AttributeExpr {{.*}} Value<"10: i32">
Pattern {
  let attr = attr<"10: i32">;

  erase _: Op;
}

// -----

// CHECK: Module
// CHECK: `-AttributeExpr {{.*}} Value<"10:i32">
Pattern {
  let attr = 10 : i32;
  erase _: Op;
}

// -----

// CHECK: Module
// CHECK: `-AttributeExpr {{.*}} Value<""value"">
Pattern {
  let attr = "value";
  erase _: Op;
}

// -----

// CHECK: |-NamedAttributeDecl {{.*}}  Name<some_array>
// CHECK: `-UserRewriteDecl {{.*}} Name<__builtin_addElemToArrayAttr> ResultType<Attr>
// CHECK:   `Arguments`
// CHECK:     CallExpr {{.*}} Type<Attr>
// CHECK:       UserRewriteDecl {{.*}} Name<__builtin_createArrayAttr> ResultType<Attr>
// CHECK:     CallExpr {{.*}} Type<Attr>
// CHECK:       UserRewriteDecl {{.*}} Name<__builtin_addEntryToDictionaryAttr_rewrite> ResultType<Attr>
// CHECK:         `Arguments`
// CHECK:           CallExpr {{.*}} Type<Attr>
// CHECK:             UserRewriteDecl {{.*}} Name<__builtin_createDictionaryAttr_rewrite> ResultType<Attr>
// CHECK:             AttributeExpr {{.*}} Value<""firstAttr"">

Pattern {
  let root = op<test.op> -> ();
  let attr = attr<"\"test\"">;
  rewrite root with {
      let newRoot = op<test.success>() { some_array =  [ {"firstAttr" = attr<"\"test\"">}], attr} -> ();
      replace root with newRoot;
  };
}

// -----

//     CHECK:LetStmt {{.*}}
//CHECK-NEXT:`-VariableDecl {{.*}} Name<dictionary> Type<Attr>
//CHECK-NEXT:  `-CallExpr {{.*}} Type<Attr>
//CHECK-NEXT:    `-DeclRefExpr {{.*}} Type<Constraint>
//CHECK-NEXT:      `-UserConstraintDecl {{.*}} Name<__builtin_createDictionaryAttr_constraint> ResultType<Attr>
//CHECK-NEXT:        `Results`
//CHECK-NEXT:          `-VariableDecl {{.*}} Name<> Type<Attr>
//CHECK-NEXT:            `Constraints`
//CHECK-NEXT:              `-AttrConstraintDecl {{.*}}
//CHECK-NEXT:ReturnStmt {{.*}}

Constraint getEmptyDict() -> Attr {
  let dictionary = {};
  return dictionary;
}

// -----

//     CHECK:LetStmt {{.*}}
//CHECK-NEXT:`-VariableDecl {{.*}} Name<dictionary> Type<Attr>
//CHECK-NEXT:  `-CallExpr {{.*}} Type<Attr>
//CHECK-NEXT:    `-DeclRefExpr {{.*}} Type<Constraint>
//CHECK-NEXT:      `-UserConstraintDecl {{.*}} Name<__builtin_addEntryToDictionaryAttr_constraint> ResultType<Attr>
//     CHECK:    `Arguments`
//CHECK-NEXT:      |-CallExpr {{.*}} Type<Attr>
//CHECK-NEXT:      | `-DeclRefExpr {{.*}} Type<Constraint>
//CHECK-NEXT:      |   `-UserConstraintDecl {{.*}} Name<__builtin_createDictionaryAttr_constraint> ResultType<Attr>
//CHECK-NEXT:      |     `Results`
//CHECK-NEXT:      |       `-VariableDecl {{.*}} Name<> Type<Attr>
//CHECK-NEXT:      |         `Constraints`
//CHECK-NEXT:      |           `-AttrConstraintDecl {{.*}}
//CHECK-NEXT:      |-DeclRefExpr {{.*}} Type<Attr>
//CHECK-NEXT:      | `-VariableDecl {{.*}} Name<dict0> Type<Attr>
//CHECK-NEXT:      |   `-AttributeExpr {{.*}} Value<""test"">
//CHECK-NEXT:      `-AttributeExpr {{.*}} Value<""String"">
//CHECK-NEXT:ReturnStmt {{.*}}

Constraint getPopulatedDict() -> Attr {
  let dictionary = { test = "String" };
  return dictionary;
}

// -----

//===----------------------------------------------------------------------===//
// CallExpr
//===----------------------------------------------------------------------===//

// CHECK: Module
// CHECK: |-UserConstraintDecl {{.*}} Name<MakeRootOp> ResultType<Op<my_dialect.foo>>
// CHECK:   `-CallExpr {{.*}} Type<Op<my_dialect.foo>>
// CHECK:     `-DeclRefExpr {{.*}} Type<Constraint>
// CHECK:       `-UserConstraintDecl {{.*}} Name<MakeRootOp> ResultType<Op<my_dialect.foo>>
Constraint MakeRootOp() => op<my_dialect.foo>;

Pattern {
  erase MakeRootOp();
}

// -----

// CHECK: Module
// CHECK: |-UserRewriteDecl {{.*}} Name<CreateNewOp> ResultType<Op<my_dialect.foo>>
// CHECK: `-PatternDecl {{.*}}
// CHECK:   `-CallExpr {{.*}} Type<Op<my_dialect.foo>>
// CHECK:     `-DeclRefExpr {{.*}} Type<Rewrite>
// CHECK:       `-UserRewriteDecl {{.*}} Name<CreateNewOp> ResultType<Op<my_dialect.foo>>
// CHECK:     `Arguments`
// CHECK:       `-MemberAccessExpr {{.*}} Member<$results> Type<ValueRange>
// CHECK:         `-DeclRefExpr {{.*}} Type<Op<my_dialect.bar>>
// CHECK:           `-VariableDecl {{.*}} Name<inputOp> Type<Op<my_dialect.bar>>
Rewrite CreateNewOp(inputs: ValueRange) => op<my_dialect.foo>(inputs);

Pattern {
  let inputOp = op<my_dialect.bar>;
  replace op<my_dialect.bar>(inputOp) with CreateNewOp(inputOp);
}

// -----

// CHECK: Module {{.*}}
// CHECK:  -UserConstraintDecl {{.*}} Name<TestConstraint> ResultType<Tuple<>>
// CHECK: `-PatternDecl {{.*}}
// CHECK:   -CallExpr {{.*}} Type<Tuple<>> Negated
// CHECK:     `-DeclRefExpr {{.*}} Type<Constraint>
// CHECK:       `-UserConstraintDecl {{.*}} Name<TestConstraint> ResultType<Tuple<>>
Constraint TestConstraint(op: Op);

Pattern {
  let inputOp = op<my_dialect.bar>;
  not TestConstraint(inputOp);
  erase inputOp;
}

// -----

//===----------------------------------------------------------------------===//
// MemberAccessExpr
//===----------------------------------------------------------------------===//

// CHECK: Module
// CHECK: `-VariableDecl {{.*}} Name<firstEltIndex> Type<Op>
// CHECK:   `-MemberAccessExpr {{.*}} Member<0> Type<Op>
// CHECK:     `-DeclRefExpr {{.*}} Type<Tuple<firstElt: Op>>
// CHECK: `-VariableDecl {{.*}} Name<firstEltName> Type<Op>
// CHECK:   `-MemberAccessExpr {{.*}} Member<firstElt> Type<Op>
// CHECK:     `-DeclRefExpr {{.*}} Type<Tuple<firstElt: Op>>
Pattern {
  let tuple = (firstElt = _: Op);
  let firstEltIndex = tuple.0;
  let firstEltName = tuple.firstElt;

  erase _: Op;
}

// -----

// Implicitly convert single element Tuple<Attr> to Attr
// CHECK: Module
// CHECK: `-MemberAccessExpr {{.*}} Member<0> Type<Attr>
// CHECK:   `-TupleExpr {{.*}} Type<Tuple<Attr>>
// CHECK:     `-AttributeExpr {{.*}} Value<"10: i32">
Constraint checkAttr(attr: Attr);
Pattern {
  let tuple = (attr<"10: i32">);
  checkAttr(tuple);
  erase _: Op;
}

// -----

#include "include/ops.td"

// CHECK: Module
// CHECK: `-VariableDecl {{.*}} Name<firstEltIndex> Type<Value>
// CHECK:   `-MemberAccessExpr {{.*}} Member<0> Type<Value>
// CHECK:     `-DeclRefExpr {{.*}} Type<Op<test.all_single>>
// CHECK: `-VariableDecl {{.*}} Name<firstEltName> Type<Value>
// CHECK:   `-MemberAccessExpr {{.*}} Member<result> Type<Value>
// CHECK:     `-DeclRefExpr {{.*}} Type<Op<test.all_single>>
Pattern {
  let op: Op<test.all_single>;
  let firstEltIndex = op.0;
  let firstEltName = op.result;

  erase op;
}

// -----

// CHECK: Module
// CHECK: `-VariableDecl {{.*}} Name<op> Type<Op<my_dialect.unregistered_foo>>
// CHECK:   `-OperationExpr {{.*}} Type<Op<my_dialect.unregistered_foo>>
// CHECK:     `-OpNameDecl {{.*}} Name<my_dialect.unregistered_foo>
// CHECK:     `Operands`
// CHECK:       `-MemberAccessExpr {{.*}} Member<0> Type<Value>
// CHECK:         `-OperationExpr {{.*}} Type<Op<my_dialect.unregistered_bar>>
// CHECK:           `-OpNameDecl {{.*}} Name<my_dialect.unregistered_bar>
// CHECK:           `Operands`
// CHECK:             `-DeclRefExpr {{.*}} Type<ValueRange>
// CHECK:               `-VariableDecl {{.*}} Name<_> Type<ValueRange>
// CHECK:                 `Constraints`
// CHECK:                   `-ValueRangeConstraintDecl
Pattern {
  let op = op<my_dialect.unregistered_foo>(op<my_dialect.unregistered_bar>.0);
  erase op;
}

// -----

//===----------------------------------------------------------------------===//
// OperationExpr
//===----------------------------------------------------------------------===//

// Test a non-constrained operation expression, and ensure that we don't treat
// unconstrained as "not present"(e.g. zero operands).

// CHECK: Module
// CHECK: `-OperationExpr {{.*}} Type<Op>
// CHECK:   `-OpNameDecl
// CHECK:   `Operands`
// CHECK:     `-DeclRefExpr {{.*}} Type<ValueRange>
// CHECK:       `-VariableDecl {{.*}} Name<_> Type<ValueRange>
// CHECK:         `Constraints`
// CHECK:           `-ValueRangeConstraintDecl
// CHECK:   `Result Types`
// CHECK:     `-DeclRefExpr {{.*}} Type<TypeRange>
// CHECK:       `-VariableDecl {{.*}} Name<_> Type<TypeRange>
// CHECK:         `Constraints`
// CHECK:           `-TypeRangeConstraintDecl
Pattern {
  erase op<>;
}

// -----

// Test explicitly empty operand/result/etc. lists, which are different from the
// "unconstrained" examples above.

// CHECK: Module
// CHECK: `-OperationExpr {{.*}} Type<Op>
// CHECK:   `-OpNameDecl
// CHECK-NOT: `Operands`
// CHECK-NOT: `Result Types`
Pattern {
  erase op<>() -> ();
}

// -----

// CHECK: Module
// CHECK: `-OperationExpr {{.*}} Type<Op<my_dialect.foo>>
// CHECK:   `-OpNameDecl {{.*}} Name<my_dialect.foo>
Pattern {
  erase op<my_dialect.foo>;
}

// -----

// CHECK: Module
// CHECK: `-OperationExpr {{.*}} Type<Op>
// CHECK:   `-OpNameDecl
// CHECK:   `Operands`
// CHECK:     |-DeclRefExpr {{.*}} Type<Value>
// CHECK:     |-DeclRefExpr {{.*}} Type<ValueRange>
// CHECK:     `-DeclRefExpr {{.*}} Type<Value>
Pattern {
  erase op<>(_: Value, _: ValueRange, _: Value);
}

// -----

// CHECK: Module
// CHECK: `-OperationExpr {{.*}} Type<Op>
// CHECK:   `-OpNameDecl
// CHECK:   `Operands`
// CHECK:     `-MemberAccessExpr {{.*}} Member<$results> Type<ValueRange>
// CHECK:       `-OperationExpr {{.*}} Type<Op<my_dialect.bar>>
// CHECK:         `-OpNameDecl {{.*}} Name<my_dialect.bar>
Pattern {
  erase op<>(op<my_dialect.bar>);
}

// -----

// CHECK: Module
// CHECK: `-OperationExpr {{.*}} Type<Op>
// CHECK:   `-OpNameDecl
// CHECK:   `Attributes`
// CHECK:     |-NamedAttributeDecl {{.*}} Name<unitAttr>
// CHECK:       `-AttributeExpr {{.*}} Value<"unit">
// CHECK:     `-NamedAttributeDecl {{.*}} Name<normal$Attr>
// CHECK:       `-DeclRefExpr {{.*}} Type<Attr>

Pattern {
  erase op<> {unitAttr, "normal$Attr" = _: Attr};
}

// -----

// CHECK: Module
// CHECK: `-OperationExpr {{.*}} Type<Op>
// CHECK:   `-OpNameDecl
// CHECK:   `Result Types`
// CHECK:     |-DeclRefExpr {{.*}} Type<Type>
// CHECK:     |-DeclRefExpr {{.*}} Type<TypeRange>
// CHECK:     `-DeclRefExpr {{.*}} Type<Type>
Pattern {
  erase op<> -> (_: Type, _: TypeRange, _: Type);
}

// -----

// Test that we don't need to provide values if all elements
// are optional.

#include "include/ops.td"

// CHECK: Module
// CHECK:  -OperationExpr {{.*}} Type<Op<test.multi_variadic>>
// CHECK-NOT:   `Operands`
// CHECK-NOT:   `Result Types`
// CHECK:  -OperationExpr {{.*}} Type<Op<test.all_variadic>>
// CHECK-NOT:   `Operands`
// CHECK-NOT:   `Result Types`
// CHECK:  -OperationExpr {{.*}} Type<Op<test.multi_variadic>>
// CHECK:    `Operands`
// CHECK:      -RangeExpr {{.*}} Type<ValueRange>
// CHECK:      -RangeExpr {{.*}} Type<ValueRange>
// CHECK:    `Result Types`
// CHECK:      -RangeExpr {{.*}} Type<TypeRange>
// CHECK:      -RangeExpr {{.*}} Type<TypeRange>
Pattern {
  rewrite op<test.multi_variadic>() -> () with {
    op<test.all_variadic> -> ();
    op<test.multi_variadic> -> ();
  };
}

// -----

// Test parsing of an op with an empty region

// CHECK: Module
// CHECK:  -PatternDecl {{.*}}
// CHECK:  -RewriteStmt {{.*}}
// CHECK:  -OperationExpr {{.*}} Type<Op<test.foo>>
// CHECK-SAME: numRegions:0
// CHECK:    `Operands`
// CHECK:    `Result Types`
// CHECK:    `Attributes`
// CHECK:  -OperationExpr {{.*}} Type<Op<test.foo_with_region>>
// CHECK-SAME: numRegions:1
// CHECK:    `Operands`
// CHECK:    `Result Types`
// CHECK:    `Attributes`
Pattern {
  rewrite op<test.foo>(operand: Value) {attr=attr: Attr} -> (type : Type) with {
    op<test.foo_with_region>(operand) {attr=attr} -> (type) ({});
  };
}

// -----

//===----------------------------------------------------------------------===//
// TupleExpr
//===----------------------------------------------------------------------===//

// CHECK: Module
// CHECK: `-VariableDecl {{.*}} Name<emptyTuple>
// CHECK:   `-TupleExpr {{.*}} Type<Tuple<>>
// CHECK: `-VariableDecl {{.*}} Name<mixedTuple>
// CHECK:   `-TupleExpr {{.*}} Type<Tuple<arg1: Attr, Value>>
// CHECK:     |-DeclRefExpr {{.*}} Type<Attr>
// CHECK:     `-DeclRefExpr {{.*}} Type<Value>
Pattern {
  let value: Value;

  let emptyTuple = ();
  let mixedTuple = (arg1 = _: Attr, value);

  erase _: Op;
}

// -----

//===----------------------------------------------------------------------===//
// RangeExpr
//===----------------------------------------------------------------------===//

// CHECK: Module
// CHECK: `Operands`
// CHECK:   -RangeExpr {{.*}} Type<ValueRange>
// CHECK:   -RangeExpr {{.*}} Type<ValueRange>
// CHECK:     -MemberAccessExpr {{.*}} Member<0> Type<Value>
// CHECK:     -MemberAccessExpr {{.*}} Member<1> Type<ValueRange>
// CHECK: `Result Types`
// CHECK:   -RangeExpr {{.*}} Type<TypeRange>
// CHECK:   -RangeExpr {{.*}} Type<TypeRange>
// CHECK:     -MemberAccessExpr {{.*}} Member<0> Type<Type>
// CHECK:     -MemberAccessExpr {{.*}} Member<1> Type<TypeRange>
Pattern {
  rewrite op<>(arg: Value, args: ValueRange) -> (type: Type, types: TypeRange) with {
    op<test.op>((), (arg, args)) -> ((), (type, types));
  };
}

// -----

//===----------------------------------------------------------------------===//
// TypeExpr
//===----------------------------------------------------------------------===//

// CHECK: Module
// CHECK: `-TypeExpr {{.*}} Value<"i64">
Pattern {
  let type = type<"i64">;

  erase _: Op;
}

//===----------------------------------------------------------------------===//
// Builtins
//===----------------------------------------------------------------------===//

// -----

// CHECK: Module 
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_addConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_subConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_mulConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_divConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_modConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_log2Constraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_exp2Constraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_absConstraint> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_addRewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_subRewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_mulRewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_divRewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_modRewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_log2Rewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_exp2Rewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_absRewrite> ResultType<Attr>
Pattern {
  let root = op<>(operand: Value, operands: ValueRange) -> (type: Type, types: TypeRange);
  let a : Attr = attr<"4 : i32">;
  let b : Attr = attr<"5 : i32">;
  let addConstraint : Attr = a + b;
  let subConstraint : Attr = a - b;
  let mulConstraint : Attr = a * b;
  let divConstraint : Attr = a / b;
  let modConstraint : Attr = a % b;
  let log2Constraint : Attr = log2(a);
  let exp2Constraint : Attr = exp2(b);
  let absConstraint : Attr = math_abs(attr<"-4 : si32">);
  rewrite root with {
    let addRewrite : Attr = attr<"4 : i32"> + attr<"5 : i32">;
    let subRewrite : Attr = attr<"4 : i32"> - attr<"5 : i32">;
    let mulRewrite : Attr = attr<"4 : i32"> * attr<"5 : i32">;
    let divRewrite : Attr = attr<"4 : i32"> / attr<"5 : i32">;
    let modRewrite : Attr = attr<"4 : i32"> % attr<"5 : i32">;
    let log2Rewrite : Attr = log2(attr<"4 : i32">);
    let exp2Rewrite : Attr = exp2(attr<"4 : i32">);
    let absRewrite : Attr = math_abs(attr<"-4 : si32">);
    erase root;
  };
}

// -----

// CHECK: PatternDecl {{.*}} Name<TestOperatorContext>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_addConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_subConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_mulConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_divConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_modConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_log2Constraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_exp2Constraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_absConstraint> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_addRewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_subRewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_mulRewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_divRewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_modRewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_log2Rewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_exp2Rewrite> ResultType<Attr>
// CHECK: UserRewriteDecl {{.*}} Name<__builtin_absRewrite> ResultType<Attr>
Constraint TestConstraint(attr: Attr, op: Op, type: Type, value: Value, typeRange: TypeRange, valueRange: ValueRange) {
  let a : Attr = attr<"4 : i32">;
  let b : Attr = attr<"5 : i32">;
  let addConstraint : Attr = a + b;
  let subConstraint : Attr = a - b;
  let mulConstraint : Attr = a * b;
  let divConstraint : Attr = a / b;
  let modConstraint : Attr = a % b;
  let log2Constraint : Attr = log2(a);
  let exp2Constraint : Attr = exp2(b);
  let absConstraint : Attr = math_abs(attr<"-4 : si32">);
}

Rewrite TestRewrite(attr: Attr, op: Op, type: Type, value: Value, typeRange: TypeRange, valueRange: ValueRange) {
  let c : Attr = attr<"4 : i32">;
  let d : Attr = attr<"5 : i32">;
  let addRewrite : Attr = c + d;
  let subRewrite : Attr = c - d;
  let mulRewrite : Attr = c * d;
  let divRewrite : Attr = c / d;
  let modRewrite : Attr = c % d;
  let log2Rewrite : Attr = log2(c);
  let exp2Rewrite : Attr = exp2(d);
  let absRewrite : Attr = math_abs(attr<"-4 : si32">);
}

Pattern TestOperatorContext {
  let root = op<>(operand: Value, operands: ValueRange) -> (type: Type, types: TypeRange);
  TestConstraint(/*attr=*/attr<"true">,  /*op=*/root, /*type=*/type, /*value=*/operand, /*typeRange=*/types, /*valueRange=*/operands);
  rewrite root with {
    TestRewrite(/*attr=*/attr<"true">, /*op=*/root, /*type=*/type, /*value=*/operand, /*typeRange=*/types, /*valueRange=*/operands);
    erase root;
  };
}

// -----

// CHECK: -UserConstraintDecl {{.*}} Name<__builtin_log2Constraint> ResultType<Attr>
// CHECK: Arguments
// CHECK: -UserConstraintDecl {{.*}} Name<__builtin_addConstraint> ResultType<Attr>
// CHECK: -UserConstraintDecl {{.*}} Name<__builtin_exp2Constraint> ResultType<Attr>
// CHECK: Arguments
// CHECK: -UserConstraintDecl {{.*}} Name<__builtin_addConstraint> ResultType<Attr>
// CHECK: -UserConstraintDecl {{.*}} Name<__builtin_absConstraint> ResultType<Attr>
// CHECK: Arguments
// CHECK: -UserConstraintDecl {{.*}} Name<__builtin_addConstraint> ResultType<Attr>
Pattern {
  let log2Constraint : Attr = log2(attr<"4 : i32"> + attr<"4 : i32">);
  let exp2Constraint : Attr = exp2(attr<"2 : i32"> + attr<"2 : i32">);
  let absConstraint : Attr = math_abs(attr<"-4 : si32"> + attr<"-2 : si32">);
  erase _: Op;
}

// -----
// Operators without assignment allowed outside rewrite section

// CHECK-NOT: LetStmt
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_addConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_subConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_mulConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_divConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_modConstraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_log2Constraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_exp2Constraint> ResultType<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_absConstraint> ResultType<Attr>
Pattern {
  attr<"4 : i32"> + attr<"5 : i32">;
  attr<"4 : i32"> - attr<"5 : i32">;
  attr<"4 : i32"> * attr<"5 : i32">;
  attr<"4 : i32"> / attr<"5 : i32">;
  attr<"4 : i32"> % attr<"5 : i32">;
  log2(attr<"4 : i32">);
  exp2(attr<"4 : i32">);
  math_abs(attr<"-4 : si32">);
  erase _: Op;
}

// -----
// CHECK: VariableDecl {{.*}} Name<a> Type<Attr>
// CHECK: VariableDecl {{.*}} Name<b> Type<Attr>
// CHECK: VariableDecl {{.*}} Name<c> Type<Attr>
// CHECK: VariableDecl {{.*}} Name<d> Type<Attr>
// CHECK:   UserConstraintDecl {{.*}} Name<__builtin_subConstraint> ResultType<Attr>
// CHECK:     Arguments
// CHECK:       UserConstraintDecl {{.*}} Name<__builtin_addConstraint> ResultType<Attr>
// CHECK:         Arguments
// CHECK:           VariableDecl {{.*}} Name<a> Type<Attr>
// CHECK:           VariableDecl {{.*}} Name<b> Type<Attr>
// CHECK:       VariableDecl {{.*}} Name<c> Type<Attr>
// CHECK: UserConstraintDecl {{.*}} Name<__builtin_modConstraint> ResultType<Attr>
// CHECK: Arguments
// CHECK:   UserConstraintDecl {{.*}} Name<__builtin_divConstraint> ResultType<Attr>
// CHECK:     Arguments
// CHECK:       UserConstraintDecl {{.*}} Name<__builtin_mulConstraint> ResultType<Attr>
// CHECK:         Arguments
// CHECK:           VariableDecl {{.*}} Name<a> Type<Attr>
// CHECK:           VariableDecl {{.*}} Name<b> Type<Attr>
// CHECK:       VariableDecl {{.*}} Name<c> Type<Attr>
// CHECK:    VariableDecl {{.*}} Name<d> Type<Attr>

Pattern {
  let a : Attr = attr<"4 : i32">;
  let b : Attr = attr<"5 : i32">;
  let c : Attr = attr<"6 : i32">;
  let d : Attr = attr<"1 : i32">;
  let x : Attr = a + b - c;
  let y : Attr = a * b / c % d;
  erase _: Op;
}

// -----
// CHECK:  VariableDecl {{.*}} Name<a> Type<Attr>
// CHECK:  VariableDecl {{.*}} Name<b> Type<Attr>
// CHECK:  VariableDecl {{.*}} Name<c> Type<Attr>
// CHECK:  UserConstraintDecl {{.*}} Name<__builtin_addConstraint> ResultType<Attr>
// CHECK:    Arguments
// CHECK:      VariableDecl {{.*}} Name<a> Type<Attr>
// CHECK:      UserConstraintDecl {{.*}} Name<__builtin_mulConstraint> ResultType<Attr>
// CHECK:        Arguments
// CHECK:          VariableDecl {{.*}} Name<b> Type<Attr>
// CHECK:          VariableDecl {{.*}} Name<c> Type<Attr>
Pattern {
  let a : Attr = attr<"4 : i32">;
  let b : Attr = attr<"5 : i32">;
  let c : Attr = attr<"6 : i32">;
  let x : Attr = a + b * c;
  erase _: Op;
}