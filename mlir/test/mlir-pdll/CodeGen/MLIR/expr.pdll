// RUN: mlir-pdll %s -I %S -I %S/../../../../include -split-input-file -x mlir | FileCheck %s

//===----------------------------------------------------------------------===//
// AttributeExpr
//===----------------------------------------------------------------------===//

// CHECK: pdl.pattern @AttrExpr
// CHECK: %[[ATTR:.*]] = attribute = 10
// CHECK: operation({{.*}}) {"attr" = %[[ATTR]]}
Pattern AttrExpr => erase op<> { attr = attr<"10"> };

// -----

//===----------------------------------------------------------------------===//
// CallExpr
//===----------------------------------------------------------------------===//

// CHECK: pdl.pattern @TestCallWithArgsAndReturn
// CHECK: %[[ROOT:.*]] = operation
// CHECK: rewrite %[[ROOT]]
// CHECK: %[[REPL_OP:.*]] = operation "test.op"
// CHECK: %[[RESULTS:.*]] = results of %[[REPL_OP]]
// CHECK: replace %[[ROOT]] with(%[[RESULTS]] : !pdl.range<value>)
Rewrite TestRewrite(root: Op) -> ValueRange => root;
Pattern TestCallWithArgsAndReturn => replace root: Op with TestRewrite(op<test.op>);

// -----

// CHECK: pdl.pattern @TestExternalCall
// CHECK: %[[ROOT:.*]] = operation
// CHECK: rewrite %[[ROOT]]
// CHECK: %[[RESULTS:.*]] = apply_native_rewrite "TestRewrite"(%[[ROOT]] : !pdl.operation) : !pdl.range<value>
// CHECK: replace %[[ROOT]] with(%[[RESULTS]] : !pdl.range<value>)
Rewrite TestRewrite(op: Op) -> ValueRange;
Pattern TestExternalCall => replace root: Op with TestRewrite(root);

// -----

// CHECK: pdl.pattern @TestExternalNegatedCall
// CHECK: %[[ROOT:.*]] = operation
// CHECK: apply_native_constraint  "TestConstraint"(%[[ROOT]] : !pdl.operation) {isNegated = true}
// CHECK: rewrite %[[ROOT]]
// CHECK: erase %[[ROOT]]
Constraint TestConstraint(op: Op);
Pattern TestExternalNegatedCall with benefit(1) {
    let root = op : Op;
    !TestConstraint(root);
    erase root;
}

// -----

//===----------------------------------------------------------------------===//
// MemberAccessExpr
//===----------------------------------------------------------------------===//

// Handle implicit "all" operation results access.
// CHECK: pdl.pattern @OpAllResultMemberAccess
// CHECK: %[[OP0:.*]] = operation
// CHECK: %[[OP0_RES:.*]] = result 0 of %[[OP0]]
// CHECK: %[[OP1:.*]] = operation
// CHECK: %[[OP1_RES:.*]] = results of %[[OP1]]
// CHECK: operation(%[[OP0_RES]], %[[OP1_RES]] : !pdl.value, !pdl.range<value>)
Pattern OpAllResultMemberAccess {
  let singleVar: Value = op<>;
  let rangeVar: ValueRange = op<>;
  erase op<>(singleVar, rangeVar);
}

// -----

// Handle result indexing on unregistered op.
// CHECK: pdl.pattern @UnregisteredOpResultIndexing
// CHECK: %[[BAR_OP:.*]] = operation "my_dialect.unregistered_bar"
// CHECK: %[[BAR_RES:.*]] = result 0 of %[[BAR_OP]]
// CHECK: operation "my_dialect.unregistered_foo"(%[[BAR_RES]] : !pdl.value)
Pattern UnregisteredOpResultIndexing {
  let bar : Op<my_dialect.unregistered_bar>;
  let op = op<my_dialect.unregistered_foo>(bar.0);
  erase op;
}

// -----

// Handle implicit "named" operation results access.

#include "include/ops.td"

// CHECK: pdl.pattern @OpResultMemberAccess
// CHECK: %[[OP0:.*]] = operation
// CHECK: %[[RES:.*]] = results 0 of %[[OP0]] -> !pdl.value
// CHECK: %[[RES1:.*]] = results 0 of %[[OP0]] -> !pdl.value
// CHECK: %[[RES2:.*]] = results 1 of %[[OP0]] -> !pdl.range<value>
// CHECK: %[[RES3:.*]] = results 1 of %[[OP0]] -> !pdl.range<value>
// CHECK: operation(%[[RES]], %[[RES1]], %[[RES2]], %[[RES3]] : !pdl.value, !pdl.value, !pdl.range<value>, !pdl.range<value>)
Pattern OpResultMemberAccess {
  let op: Op<test.with_results>;
  erase op<>(op.0, op.result, op.1, op.var_result);
}

// -----

// CHECK: pdl.pattern @TupleMemberAccessNumber
// CHECK: %[[FIRST:.*]] = operation "test.first"
// CHECK: %[[SECOND:.*]] = operation "test.second"
// CHECK: rewrite %[[FIRST]] {
// CHECK:   replace %[[FIRST]] with %[[SECOND]]
Pattern TupleMemberAccessNumber {
  let firstOp = op<test.first>;
  let secondOp = op<test.second>(firstOp);
  let tuple = (firstOp, secondOp);
  replace tuple.0 with tuple.1;
}

// -----

// CHECK: pdl.pattern @TupleMemberAccessName
// CHECK: %[[FIRST:.*]] = operation "test.first"
// CHECK: %[[SECOND:.*]] = operation "test.second"
// CHECK: rewrite %[[FIRST]] {
// CHECK:   replace %[[FIRST]] with %[[SECOND]]
Pattern TupleMemberAccessName {
  let firstOp = op<test.first>;
  let secondOp = op<test.second>(firstOp);
  let tuple = (first = firstOp, second = secondOp);
  replace tuple.first with tuple.second;
}

// -----

//===----------------------------------------------------------------------===//
// RangeExpr
//===----------------------------------------------------------------------===//

// CHECK: pdl.pattern @RangeExpr
// CHECK: %[[ARG:.*]] = operand
// CHECK: %[[ARGS:.*]] = operands
// CHECK: %[[TYPE:.*]] = type
// CHECK: %[[TYPES:.*]] = types
// CHECK:   range : !pdl.range<value>
// CHECK:   range %[[ARG]], %[[ARGS]] : !pdl.value, !pdl.range<value>
// CHECK:   range : !pdl.range<type>
// CHECK:   range %[[TYPE]], %[[TYPES]] : !pdl.type, !pdl.range<type>
Pattern RangeExpr {
  replace op<>(arg: Value, args: ValueRange) -> (type: Type, types: TypeRange)
    with op<test.op>((), (arg, args)) -> ((), (type, types));
}

// -----

//===----------------------------------------------------------------------===//
// TypeExpr
//===----------------------------------------------------------------------===//

// CHECK: pdl.pattern @TypeExpr
// CHECK: %[[TYPE:.*]] = type : i32
// CHECK: operation({{.*}}) -> (%[[TYPE]] : !pdl.type)
Pattern TypeExpr => erase op<> -> (type<"i32">);

// -----

//===----------------------------------------------------------------------===//
// Parse attributes and rewrite
//===----------------------------------------------------------------------===//

// Rewriter helpers declarations.
Rewrite createDictionaryAttr() -> Attr;
Rewrite addEntryToDictionaryAttr(dict: Attr, attrName: Attr, attr : Attr) -> Attr;
Rewrite createArrayAttr() -> Attr;
Rewrite addElemToArrayAttr(arrayAttr: Attr, newElement: Attr) -> Attr;

// CHECK-LABEL:   pdl.pattern @RewriteOneEntryDictionary
// CHECK:           %[[VAL_1:.*]] = operation "test.op"
// CHECK:           %[[VAL_2:.*]] = attribute = "test"
// CHECK:           rewrite %[[VAL_1]] {
// CHECK:             %[[VAL_3:.*]] = apply_native_rewrite "createDictionaryAttr"
// CHECK:             %[[VAL_4:.*]] = attribute = "firstAttr"
// CHECK:             %[[VAL_5:.*]] = apply_native_rewrite "addEntryToDictionaryAttr"(%[[VAL_3]], %[[VAL_4]], %[[VAL_2]]
// CHECK:             %[[VAL_6:.*]] = operation "test.success"  {"some_dictionary" = %[[VAL_5]]}
// CHECK:             replace %[[VAL_1]] with %[[VAL_6]]
Pattern RewriteOneEntryDictionary {
  let root = op<test.op> -> ();
  let attr1 = attr<"\"test\"">;
  rewrite root with {
      let newRoot = op<test.success>() { some_dictionary = {firstAttr=attr1} } -> ();
      replace root with newRoot;
  };
}

// -----

// Rewriter helpers declarations.
Rewrite createDictionaryAttr() -> Attr;
Rewrite addEntryToDictionaryAttr(dict: Attr, attrName: Attr, attr : Attr) -> Attr;

// CHECK-LABEL:   pdl.pattern @RewriteMultipleEntriesDictionary
// CHECK:           %[[VAL_1:.*]] = operation "test.op"
// CHECK:           %[[VAL_2:.*]] = attribute = "test2"
// CHECK:           %[[VAL_3:.*]] = attribute = "test3"
// CHECK:           rewrite %[[VAL_1]] {
// CHECK:             %[[VAL_4:.*]] = apply_native_rewrite "createDictionaryAttr"
// CHECK:             %[[VAL_5:.*]] = attribute = "firstAttr"
// CHECK:             %[[VAL_6:.*]] = attribute = "test1"
// CHECK:             %[[VAL_7:.*]] = apply_native_rewrite "addEntryToDictionaryAttr"(%[[VAL_4]], %[[VAL_5]], %[[VAL_6]]
// CHECK:             %[[VAL_8:.*]] = attribute = "secondAttr"
// CHECK:             %[[VAL_9:.*]] = apply_native_rewrite "addEntryToDictionaryAttr"(%[[VAL_7]], %[[VAL_8]], %[[VAL_2]]
// CHECK:             %[[VAL_10:.*]] = attribute = "thirdAttr"
// CHECK:             %[[VAL_11:.*]] = apply_native_rewrite "addEntryToDictionaryAttr"(%[[VAL_9]], %[[VAL_10]], %[[VAL_3]]
// CHECK:             %[[VAL_12:.*]] = operation "test.success"  {"some_dictionary" = %[[VAL_11]]}
// CHECK:             replace %[[VAL_1]] with %[[VAL_12]]
Pattern RewriteMultipleEntriesDictionary {
  let root = op<test.op> -> ();
  let attr2 = attr<"\"test2\"">;
  let attr3 = attr<"\"test3\"">;
  rewrite root with {
      let newRoot = op<test.success>() { some_dictionary = {"firstAttr" = attr<"\"test1\"">, secondAttr = attr2, thirdAttr = attr3} } -> ();
      replace root with newRoot;
  };
}

// -----

// Rewriter helpers declarations.
Rewrite createDictionaryAttr() -> Attr;
Rewrite addEntryToDictionaryAttr(dict: Attr, attrName: Attr, attr : Attr) -> Attr;
Rewrite createArrayAttr() -> Attr;
Rewrite addElemToArrayAttr(arrayAttr: Attr, newElement: Attr) -> Attr;

// CHECK-LABEL:   pdl.pattern @RewriteOneDictionaryArrayAttr
// CHECK:           %[[VAL_1:.*]] = operation "test.op"
// CHECK:           rewrite %[[VAL_1]] {
// CHECK:             %[[VAL_2:.*]] = apply_native_rewrite "createArrayAttr"
// CHECK:             %[[VAL_3:.*]] = apply_native_rewrite "createDictionaryAttr"
// CHECK:             %[[VAL_4:.*]] = attribute = "firstAttr"
// CHECK:             %[[VAL_5:.*]] = attribute = "test1"
// CHECK:             %[[VAL_6:.*]] = apply_native_rewrite "addEntryToDictionaryAttr"(%[[VAL_3]], %[[VAL_4]], %[[VAL_5]]
// CHECK:             %[[VAL_7:.*]] = apply_native_rewrite "addElemToArrayAttr"(%[[VAL_2]], %[[VAL_6]]
// CHECK:             %[[VAL_8:.*]] = operation "test.success"  {"some_array" = %[[VAL_7]]}
// CHECK:             replace %[[VAL_1]] with %[[VAL_8]]
Pattern RewriteOneDictionaryArrayAttr {
  let root = op<test.op> -> ();
  rewrite root with {
      let newRoot = op<test.success>() { some_array = [ {"firstAttr" = attr<"\"test1\"">}]} -> ();
      replace root with newRoot;
  };
}

// -----

// Rewriter helpers declarations.
Rewrite createDictionaryAttr() -> Attr;
Rewrite addEntryToDictionaryAttr(dict: Attr, attrName: Attr, attr : Attr) -> Attr;
Rewrite createArrayAttr() -> Attr;
Rewrite addElemToArrayAttr(arrayAttr: Attr, newElement: Attr) -> Attr;

// CHECK-LABEL:   pdl.pattern @RewriteMultiplyElementsArrayAttr
// CHECK:           %[[VAL_1:.*]] = operation "test.op"
// CHECK:           %[[VAL_2:.*]] = attribute = "test2"
// CHECK:           rewrite %[[VAL_1]] {
// CHECK:             %[[VAL_3:.*]] = apply_native_rewrite "createArrayAttr"
// CHECK:             %[[VAL_4:.*]] = apply_native_rewrite "createDictionaryAttr"
// CHECK:             %[[VAL_5:.*]] = attribute = "firstAttr"
// CHECK:             %[[VAL_6:.*]] = attribute = "test1"
// CHECK:             %[[VAL_7:.*]] = apply_native_rewrite "addEntryToDictionaryAttr"(%[[VAL_4]], %[[VAL_5]], %[[VAL_6]]
// CHECK:             %[[VAL_8:.*]] = apply_native_rewrite "addElemToArrayAttr"(%[[VAL_3]], %[[VAL_7]]
// CHECK:             %[[VAL_9:.*]] = apply_native_rewrite "addElemToArrayAttr"(%[[VAL_8]], %[[VAL_2]]
// CHECK:             %[[VAL_10:.*]] = operation "test.success"  {"some_array" = %[[VAL_9]]}
// CHECK:             replace %[[VAL_1]] with %[[VAL_10]]
Pattern RewriteMultiplyElementsArrayAttr {
  let root = op<test.op> -> ();
  let attr2 = attr<"\"test2\"">;
  rewrite root with {
      let newRoot = op<test.success>() { some_array = [ {"firstAttr" = attr<"\"test1\"">}, attr2]} -> ();
      replace root with newRoot;
  };
}